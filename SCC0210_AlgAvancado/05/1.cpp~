#include <bits/stdc++.h>
using namespace std;

#define mp make_pair
string final = "123456789ABCDEF0";

char crt(int c) {
	if (c < 10) return c + '0';
	return c - 10 + 'A';
}

int h(string& s) {
	int ret = 0;
	for (int i = 0; i < s.size(); i++) {
		ret += s[i] != final[i];
	}
	return ret;
}

int get(string& s) {
	for (int i = 0; i < s.size(); i++) if (s[i] == '0') return i;
	assert(0);
	return -1;
}

string solve(string& s) {
	unordered_map<string, string> dist;
	dist[s] = "";
	priority_queue<pair<int, string> > pq;
	pq.push(mp(0, s));
	bool L, R, U, D;

	while(pq.size()) {
		string u = pq.top().second;
		if (u == final) return dist[u];
		pq.pop();

		if (dist[u].size() > 45) continue;
		//cout << u << " - " << dist[u] << endl;
		
		int i = get(u);
		
		U = i >= 4;
		D = i <= 11;
		L = i != 0 && i != 4 && i != 8 && i != 12;
		R = i != 3 && i != 7 && i != 11 && i != 15;

		if (L) {
			string v = u;
			swap(v[i], v[i-1]);

			if (dist.find(v) == dist.end() || dist[u].size()+1 < dist[v].size()) {
				dist[v] = dist[u] + 'L';
				int w = dist[v].size() + h(u);
				pq.push(mp(-w, v));
			}
		}

		if (R) {
			string v = u;
			swap(v[i], v[i+1]);

			if (dist.find(v) == dist.end() || dist[u].size()+1 < dist[v].size()) {
				dist[v] = dist[u] + 'R';
				int w = dist[v].size() + h(u);
				pq.push(mp(-w, v));
			}
		}

		if (U) {
			string v = u;
			swap(v[i], v[i-4]);

			if (dist.find(v) == dist.end() || dist[u].size()+1 < dist[v].size()) {
				dist[v] = dist[u] + 'U';
				int w = dist[v].size() + h(u);
				pq.push(mp(-w, v));
			}
		}

		if (D) {
			string v = u;
			swap(v[i], v[i+4]);

			if (dist.find(v) == dist.end() || dist[u].size()+1 < dist[v].size()) {
				dist[v] = dist[u] + 'D';
				int w = dist[v].size() + h(u);
				pq.push(mp(-w, v));
			}
		}
	}

	return "This puzzle is not solvable.";
}

int main() {
	ios::sync_with_stdio(false); cin.tie(NULL);
	int t; cin >> t;

	while(t--) {
		string s;
		for (int i = 0; i <= 15; i++) {
			int c; cin >> c;
			s += crt(c);
		}

		cout << solve(s) << endl;
	}

}
